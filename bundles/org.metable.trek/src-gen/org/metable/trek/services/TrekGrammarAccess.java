/*
 * generated by Xtext 2.31.0
 */
package org.metable.trek.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class TrekGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.Model");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_0 = (RuleCall)cTypeAssignment.eContents().get(0);
		
		//Model:
		//    type+=Type*;
		@Override public ParserRule getRule() { return rule; }
		
		//type+=Type*
		public Assignment getTypeAssignment() { return cTypeAssignment; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0() { return cTypeTypeParserRuleCall_0; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRepsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRepsRepParserRuleCall_3_0 = (RuleCall)cRepsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Type:
		//    'type' name=ID '{'
		//    reps+=Rep*
		//    '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'type' name=ID '{'
		//reps+=Rep*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'type'
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//reps+=Rep*
		public Assignment getRepsAssignment_3() { return cRepsAssignment_3; }
		
		//Rep
		public RuleCall getRepsRepParserRuleCall_3_0() { return cRepsRepParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class RepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.Rep");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComponentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cComponentsRepComponentParserRuleCall_3_0 = (RuleCall)cComponentsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Rep:
		//    'rep' name=ID '{'
		//    components+=RepComponent+
		//    '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'rep' name=ID '{'
		//components+=RepComponent+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'rep'
		public Keyword getRepKeyword_0() { return cRepKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//components+=RepComponent+
		public Assignment getComponentsAssignment_3() { return cComponentsAssignment_3; }
		
		//RepComponent
		public RuleCall getComponentsRepComponentParserRuleCall_3_0() { return cComponentsRepComponentParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class RepComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.RepComponent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeRepComponentTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//RepComponent:
		//    type=RepComponentType name=ID ';';
		@Override public ParserRule getRule() { return rule; }
		
		//type=RepComponentType name=ID ';'
		public Group getGroup() { return cGroup; }
		
		//type=RepComponentType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//RepComponentType
		public RuleCall getTypeRepComponentTypeParserRuleCall_0_0() { return cTypeRepComponentTypeParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class RepComponentTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.RepComponentType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSystemTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RepComponentType:
		//    SystemType | TypeType;
		@Override public ParserRule getRule() { return rule; }
		
		//SystemType | TypeType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SystemType
		public RuleCall getSystemTypeParserRuleCall_0() { return cSystemTypeParserRuleCall_0; }
		
		//TypeType
		public RuleCall getTypeTypeParserRuleCall_1() { return cTypeTypeParserRuleCall_1; }
	}
	public class SystemTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.SystemType");
		private final Assignment cTypeNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cTypeNameAlternatives_0 = (Alternatives)cTypeNameAssignment.eContents().get(0);
		private final Keyword cTypeNameStringKeyword_0_0 = (Keyword)cTypeNameAlternatives_0.eContents().get(0);
		private final Keyword cTypeNameIntKeyword_0_1 = (Keyword)cTypeNameAlternatives_0.eContents().get(1);
		private final Keyword cTypeNameBooleanKeyword_0_2 = (Keyword)cTypeNameAlternatives_0.eContents().get(2);
		private final Keyword cTypeNameCharKeyword_0_3 = (Keyword)cTypeNameAlternatives_0.eContents().get(3);
		private final Keyword cTypeNameDoubleKeyword_0_4 = (Keyword)cTypeNameAlternatives_0.eContents().get(4);
		
		//SystemType:
		//    typeName=('string' | 'int' | 'boolean' | 'char' | 'double');
		@Override public ParserRule getRule() { return rule; }
		
		//typeName=('string' | 'int' | 'boolean' | 'char' | 'double')
		public Assignment getTypeNameAssignment() { return cTypeNameAssignment; }
		
		//('string' | 'int' | 'boolean' | 'char' | 'double')
		public Alternatives getTypeNameAlternatives_0() { return cTypeNameAlternatives_0; }
		
		//'string'
		public Keyword getTypeNameStringKeyword_0_0() { return cTypeNameStringKeyword_0_0; }
		
		//'int'
		public Keyword getTypeNameIntKeyword_0_1() { return cTypeNameIntKeyword_0_1; }
		
		//'boolean'
		public Keyword getTypeNameBooleanKeyword_0_2() { return cTypeNameBooleanKeyword_0_2; }
		
		//'char'
		public Keyword getTypeNameCharKeyword_0_3() { return cTypeNameCharKeyword_0_3; }
		
		//'double'
		public Keyword getTypeNameDoubleKeyword_0_4() { return cTypeNameDoubleKeyword_0_4; }
	}
	public class TypeTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.metable.trek.Trek.TypeType");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cTypeTypeCrossReference_0 = (CrossReference)cTypeAssignment.eContents().get(0);
		private final RuleCall cTypeTypeIDTerminalRuleCall_0_1 = (RuleCall)cTypeTypeCrossReference_0.eContents().get(1);
		
		//TypeType:
		//    type=[Type];
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Type]
		public Assignment getTypeAssignment() { return cTypeAssignment; }
		
		//[Type]
		public CrossReference getTypeTypeCrossReference_0() { return cTypeTypeCrossReference_0; }
		
		//ID
		public RuleCall getTypeTypeIDTerminalRuleCall_0_1() { return cTypeTypeIDTerminalRuleCall_0_1; }
	}
	
	
	private final ModelElements pModel;
	private final TypeElements pType;
	private final RepElements pRep;
	private final RepComponentElements pRepComponent;
	private final RepComponentTypeElements pRepComponentType;
	private final SystemTypeElements pSystemType;
	private final TypeTypeElements pTypeType;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TrekGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pType = new TypeElements();
		this.pRep = new RepElements();
		this.pRepComponent = new RepComponentElements();
		this.pRepComponentType = new RepComponentTypeElements();
		this.pSystemType = new SystemTypeElements();
		this.pTypeType = new TypeTypeElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.metable.trek.Trek".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//    type+=Type*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Type:
	//    'type' name=ID '{'
	//    reps+=Rep*
	//    '}';
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//Rep:
	//    'rep' name=ID '{'
	//    components+=RepComponent+
	//    '}';
	public RepElements getRepAccess() {
		return pRep;
	}
	
	public ParserRule getRepRule() {
		return getRepAccess().getRule();
	}
	
	//RepComponent:
	//    type=RepComponentType name=ID ';';
	public RepComponentElements getRepComponentAccess() {
		return pRepComponent;
	}
	
	public ParserRule getRepComponentRule() {
		return getRepComponentAccess().getRule();
	}
	
	//RepComponentType:
	//    SystemType | TypeType;
	public RepComponentTypeElements getRepComponentTypeAccess() {
		return pRepComponentType;
	}
	
	public ParserRule getRepComponentTypeRule() {
		return getRepComponentTypeAccess().getRule();
	}
	
	//SystemType:
	//    typeName=('string' | 'int' | 'boolean' | 'char' | 'double');
	public SystemTypeElements getSystemTypeAccess() {
		return pSystemType;
	}
	
	public ParserRule getSystemTypeRule() {
		return getSystemTypeAccess().getRule();
	}
	
	//TypeType:
	//    type=[Type];
	public TypeTypeElements getTypeTypeAccess() {
		return pTypeType;
	}
	
	public ParserRule getTypeTypeRule() {
		return getTypeTypeAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
